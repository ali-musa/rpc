#!/bin/env python
#
#          print signatures of all the functions named in supplied IDL file
#

import subprocess
import json
import sys
import os

#gloabl list to maintain the types for which the send and recv functions have been created
types_created = []; 

try:
	#
	#     Make sure invoked properly
	#
	if len(sys.argv) != 2:
		raise "Wrong number of arguments"

	#
	#     Make sure file exists and is readable
	#
	filename = sys.argv[1]
	if (not os.path.isfile(filename)):
		print >> sys.stderr, "Path %s does not designate a file" % filename
		raise "No file named " + filename
	if (not os.access(filename, os.R_OK)):
		print >> sys.stderr, "File %s is not readable" % filename
		raise "File " + filename + " not readable"

	#
	#     Parse declarations into a Python dictionary
	#
	decls = json.loads(subprocess.check_output(["./idl_to_json", filename]))


	# #
	# # Loop printing each function signature
	# #
	print decls["types"]
	# for  fname, fsig in decls["functions"].iteritems(): 
		
	# 	# Python Array of all args (each is a hash with keys "name" and "type")
	# 	args = fsig["arguments"]
	# 	# print args;
	# 	# break
		
	# 	# Make a string of form:  "type1 arg1, type2 arg2" for use in function sig
	# 	argstring = ', '.join([a["type"] + ' ' + a["name"] for a in args])

	# 	# print the function signature
	# 	print "%s %s(%s)" % (fsig["return_type"], fname, argstring)
	# 	# break

	# for  tname, ttype in decls["functions"].iteritems():

	

except Exception as e:
	print >> sys.stderr, "Usage: %s <idlfilename>" % sys.argv[0]






#
#		 init_proxy(proxy)
#
# takes in a proxy string and idlfilename
# and initializes it with the relevant includes
#
def init_proxy(proxy, idlfilename):
	raise NotImplementedError

#
#		 init_stub(stub)
#
# takes in a stub string and idlfilename
# and initializes it with the relevant includes
#
def init_stub(stub, idlfilename):
	raise NotImplementedError


#
#		 make_send_recv(typ, proxy, stub)
#
# takes in a type string, proxy string, stub sting and a types_dict
# and makes the send and receive for the type in both the proxy and stub
# by recursively going in a dfs manner through the types_dict.
# builtin types are leaves
# we do not revisit a visited node (i.e. do not re-create a type already created)
#
def make_send_recv(typ, proxy, stub, types_dict):
	global types_created
	if typ in types_created: # check if we have already visited
		return

	type_of_type = types_dict[typ]["type_of_type"]
	if type_of_type is "builtin":
		if typ is "void":
			pass
		elif typ is "int":
			#make int send recv
			raise NotImplementedError
		elif typ is "float":
			#make float send recv
			raise NotImplementedError
		elif typ is "string":
			#make string send recv
			raise NotImplementedError

	elif type_of_type is "struct": 		
		for member in types_dict[typ]["members"]: # for each member type recurse
			raise NotImplementedError




	types_created.append(typ)


